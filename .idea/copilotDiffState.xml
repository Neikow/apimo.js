<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/ci.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/ci.yml" />
              <option name="updatedContent" value="name: Continuous Integration&#10;&#10;on:&#10;  push:&#10;    branches: [ main, develop ]&#10;  pull_request:&#10;    branches: [ main, develop ]&#10;&#10;jobs:&#10;  test-and-lint:&#10;    runs-on: ubuntu-latest&#10;&#10;    strategy:&#10;      matrix:&#10;        node-version: [18, 20, 22]&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup Node.js ${{ matrix.node-version }}&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: ${{ matrix.node-version }}&#10;          cache: 'yarn'&#10;&#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;&#10;      - name: Run linting&#10;        run: yarn lint&#10;&#10;      - name: Run tests&#10;        run: yarn test&#10;&#10;      - name: Run test coverage&#10;        run: yarn test-coverage&#10;&#10;      - name: Upload coverage reports to Codecov&#10;        uses: codecov/codecov-action@v4&#10;        if: matrix.node-version == 20&#10;        with:&#10;          file: ./coverage/lcov.info&#10;          fail_ci_if_error: false&#10;        env:&#10;          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.github/workflows/publish.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/publish.yml" />
              <option name="updatedContent" value="name: Build, Test &amp; Publish to NPM&#10;&#10;on:&#10;  push:&#10;    tags:&#10;      - 'v*'  # Triggers on version tags like v1.0.0, v1.2.3, etc.&#10;  workflow_dispatch:  # Allows manual triggering&#10;&#10;jobs:&#10;  test:&#10;    runs-on: ubuntu-latest&#10;    &#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;        &#10;      - name: Setup Node.js&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: '18'&#10;          cache: 'yarn'&#10;          &#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;        &#10;      - name: Run linting&#10;        run: yarn lint&#10;        &#10;      - name: Run tests&#10;        run: yarn test&#10;        &#10;      - name: Run test coverage&#10;        run: yarn test-coverage&#10;&#10;  build-and-publish:&#10;    needs: test&#10;    runs-on: ubuntu-latest&#10;    &#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;        &#10;      - name: Setup Node.js&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: '18'&#10;          cache: 'yarn'&#10;          registry-url: 'https://registry.npmjs.org'&#10;          &#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;        &#10;      - name: Build package&#10;        run: yarn build&#10;        &#10;      - name: Check if dist directory exists&#10;        run: |&#10;          if [ ! -d &quot;dist&quot; ]; then&#10;            echo &quot;Build failed: dist directory not found&quot;&#10;            exit 1&#10;          fi&#10;          echo &quot;Build successful: dist directory created&quot;&#10;          &#10;      - name: Publish to NPM&#10;        run: npm publish&#10;        env:&#10;          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Apimo.js&#10;&#10;Apimo.js is a Node.js module for interacting with the Apimo API.&#10;&#10;## Usage&#10;&#10;```javascript&#10;const Apimo = require('apimo.js/dist')&#10;&#10;const api = new Apimo(&#10;  '&lt;BRIDGE_ID&gt;',&#10;  '&lt;API_TOKEN&gt;',&#10;  {&#10;    debug: true,&#10;    cultures: [&#10;      'fr_FR',&#10;      'en_GB',&#10;    ],&#10;    updateIntervals: {&#10;      properties: 1000 * 60 * 5, // 5 minutes&#10;      catalogs: 1000 * 60 * 60 * 24, // 24 hours&#10;    }&#10;  }&#10;)&#10;```&#10;&#10;The `BRIDGE_ID` and `API_TOKEN` can be asked on the support page of Apimo.&#10;&#10;## API&#10;&#10;The API endpoints are described on the [Apimo API documentation](https://apimo.net/en/api/webservice/).&#10;&#10;## Wrapper&#10;&#10;The wrapper is a set of methods that will help you to interact with the API.&#10;It can cache requests in order to avoid reaching the API rate limit, which are pretty low (1000 requests per day).&#10;The data can be set to be updated automatically, given a certain interval.&#10;&#10;## Methods&#10;&#10;### `get`&#10;&#10;Helper method to get a property from the API.&#10;&#10;```javascript&#10;api.get(['properties', 123]).then((property) =&gt; {&#10;  console.log(property) // == Property(id: 123, ...)&#10;})&#10;```&#10;&#10;### `getProperties`&#10;&#10;Get all properties from the API.&#10;&#10;```javascript&#10;api.fetchProperties().then((properties) =&gt; {&#10;  console.log(properties) // [Property(...), Property(...), ...]&#10;})&#10;```&#10;&#10;A `Property` is the data of a property, as stored in the Apimo API, it is described in&#10;the [Apimo API documentation](https://apimo.net/en/api/webservice/?child=agencies/properties#get-agencies/propertiesagencies-{agency_id}-properties).&#10;&#10;### `getAgencies`&#10;&#10;Returns the agencies linked to the bridge.&#10;&#10;```javascript&#10;api.fetchAgencies().then((agencies) =&gt; {&#10;  console.log(agencies) // [Agency(...), Agency(...), ...]&#10;})&#10;```&#10;&#10;An `Agency` is the data of an agency, as stored in the Apimo API, it is described in&#10;the [Apimo API documentation](https://apimo.net/en/api/webservice/?child=agencies#get-agenciesagencies).&#10;&#10;### `convertDate`&#10;&#10;Converts a Apimo date to a `Date` object.&#10;&#10;```javascript&#10;api.convertDate('2018-01-01').then((date) =&gt; {&#10;  console.log(date) // == Date(2018, 0, 1)&#10;})&#10;```&#10;&#10;## Installation&#10;&#10;```bash&#10;npm install github:Neikow/apimo.js&#10;```&#10;" />
              <option name="updatedContent" value="# Apimo.js&#10;&#10;[![npm version](https://badge.fury.io/js/apimo.js.svg)](https://badge.fury.io/js/apimo.js)&#10;[![CI](https://github.com/Neikow/apimo.js/actions/workflows/ci.yml/badge.svg)](https://github.com/Neikow/apimo.js/actions/workflows/ci.yml)&#10;[![codecov](https://codecov.io/gh/Neikow/apimo.js/branch/main/graph/badge.svg)](https://codecov.io/gh/Neikow/apimo.js)&#10;&#10;A comprehensive TypeScript wrapper for the [Apimo API](https://apimo.net/en/api/webservice/) with intelligent caching, rate limiting, and automatic catalog transformation for building custom Real Estate websites.&#10;&#10;## Features&#10;&#10;-  **TypeScript-first** - Full type safety with Zod schema validation&#10;-  **Smart Caching** - Multiple cache adapters (Memory, Filesystem, Dummy) with automatic invalidation&#10;-  **Rate Limiting** - Built-in request throttling to respect API limits (1000 requests/day)&#10;-  **Multi-language Support** - Automatic catalog transformation for localized content&#10;- ️ **Property &amp; Agency APIs** - Complete coverage of Apimo's real estate endpoints&#10;- ⚡ **Optimized Performance** - Intelligent catalog caching reduces API calls by 90%&#10;&#10;## Installation&#10;&#10;```bash&#10;npm install apimo.js&#10;# or&#10;yarn add apimo.js&#10;```&#10;&#10;## Quick Start&#10;&#10;```typescript&#10;import { Api } from 'apimo.js'&#10;&#10;const api = new Api(&#10;  'YOUR_BRIDGE_ID',     // Get from Apimo support&#10;  'YOUR_API_TOKEN',     // Get from Apimo support&#10;  {&#10;    culture: 'en',      // Default language&#10;    catalogs: {&#10;      cache: {&#10;        active: true,&#10;        adapter: new MemoryCache() // or FilesystemCache()&#10;      }&#10;    }&#10;  }&#10;)&#10;&#10;// Fetch properties with automatic catalog transformation&#10;const properties = await api.getProperties({&#10;  limit: 10,&#10;  offset: 0&#10;})&#10;&#10;// Get a specific property&#10;const property = await api.getProperty(123)&#10;&#10;// Fetch agencies&#10;const agencies = await api.getAgencies()&#10;```&#10;&#10;## Configuration&#10;&#10;### Basic Configuration&#10;&#10;```typescript&#10;const api = new Api(bridgeId, token, {&#10;  baseUrl: 'https://api.apimo.pro',  // API base URL&#10;  culture: 'en',                     // Default language (en, fr)&#10;  catalogs: {&#10;    cache: {&#10;      active: true,                  // Enable catalog caching&#10;      adapter: new MemoryCache()     // Cache implementation&#10;    },&#10;    transform: {&#10;      active: true,                  // Enable catalog transformation&#10;      transformFn: customTransformer // Optional custom transformer&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;### Cache Adapters&#10;&#10;#### Memory Cache (Default)&#10;```typescript&#10;import { MemoryCache } from 'apimo.js'&#10;&#10;const api = new Api(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new MemoryCache()&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;#### Filesystem Cache&#10;```typescript&#10;import { FilesystemCache } from 'apimo.js'&#10;&#10;const api = new Api(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new FilesystemCache('./cache')&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;#### Dummy Cache (No Caching)&#10;```typescript&#10;import { DummyCache } from 'apimo.js'&#10;&#10;const api = new Api(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new DummyCache()&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;## API Reference&#10;&#10;### Properties&#10;&#10;#### `getProperties(options?)`&#10;Fetch a list of properties with optional filtering.&#10;&#10;```typescript&#10;const properties = await api.getProperties({&#10;  limit: 20,&#10;  offset: 0,&#10;  culture: 'fr',&#10;  // Add property filters as needed&#10;})&#10;```&#10;&#10;#### `getProperty(id, options?)`&#10;Fetch a specific property by ID.&#10;&#10;```typescript&#10;const property = await api.getProperty(123, {&#10;  culture: 'en'&#10;})&#10;```&#10;&#10;### Agencies&#10;&#10;#### `getAgencies(options?)`&#10;Fetch a list of agencies.&#10;&#10;```typescript&#10;const agencies = await api.getAgencies({&#10;  limit: 10,&#10;  culture: 'fr'&#10;})&#10;```&#10;&#10;#### `getAgency(id, options?)`&#10;Fetch a specific agency by ID.&#10;&#10;```typescript&#10;const agency = await api.getAgency(456)&#10;```&#10;&#10;### Catalogs&#10;&#10;#### `fetchCatalogs()`&#10;Get all available catalog definitions.&#10;&#10;```typescript&#10;const catalogs = await api.fetchCatalogs()&#10;```&#10;&#10;#### `fetchCatalog(catalogName, options?)`&#10;Fetch entries for a specific catalog.&#10;&#10;```typescript&#10;const propertyTypes = await api.fetchCatalog('property_type', {&#10;  culture: 'en'&#10;})&#10;```&#10;&#10;#### `getCatalogEntries(catalogName, options?)`&#10;Get catalog entries from cache (populates cache if needed).&#10;&#10;```typescript&#10;const entries = await api.getCatalogEntries('property_category', {&#10;  culture: 'fr'&#10;})&#10;```&#10;&#10;### Low-level API&#10;&#10;#### `get(path, schema, options?)`&#10;Make a direct API call with schema validation.&#10;&#10;```typescript&#10;import { z } from 'zod'&#10;&#10;const customSchema = z.object({&#10;  id: z.number(),&#10;  name: z.string()&#10;})&#10;&#10;const result = await api.get(['custom', 'endpoint'], customSchema, {&#10;  culture: 'en',&#10;  limit: 10&#10;})&#10;```&#10;&#10;#### `fetch(...args)`&#10;Direct fetch with automatic authentication headers.&#10;&#10;```typescript&#10;const response = await api.fetch('https://api.apimo.pro/properties')&#10;```&#10;&#10;## Data Transformation&#10;&#10;Apimo.js automatically transforms catalog IDs into human-readable names:&#10;&#10;```typescript&#10;// Raw API response&#10;{&#10;  &quot;type&quot;: 1,&#10;  &quot;category&quot;: 2&#10;}&#10;&#10;// Transformed response&#10;{&#10;  &quot;type&quot;: &quot;House&quot;,&#10;  &quot;category&quot;: &quot;Sale&quot;&#10;}&#10;```&#10;&#10;### Custom Transformers&#10;&#10;```typescript&#10;const customTransformer = async (catalogName, culture, id) =&gt; {&#10;  // Your custom transformation logic&#10;  return await myCustomCatalogLookup(catalogName, culture, id)&#10;}&#10;&#10;const api = new Api(bridgeId, token, {&#10;  catalogs: {&#10;    transform: {&#10;      active: true,&#10;      transformFn: customTransformer&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;## Rate Limiting&#10;&#10;The library includes built-in rate limiting to respect Apimo's API limits:&#10;&#10;- **10 requests per second** (configurable)&#10;- **Automatic queuing** of excess requests&#10;- **Bottleneck integration** for advanced rate limiting scenarios&#10;&#10;## Error Handling&#10;&#10;```typescript&#10;try {&#10;  const properties = await api.getProperties()&#10;} catch (error) {&#10;  if (error instanceof CacheExpiredError) {&#10;    // Handle cache expiration&#10;  } else {&#10;    // Handle other API errors&#10;    console.error('API Error:', error.message)&#10;  }&#10;}&#10;```&#10;&#10;## TypeScript Support&#10;&#10;Full TypeScript support with comprehensive type definitions:&#10;&#10;```typescript&#10;import type { Property, Agency, CatalogEntry } from 'apimo.js'&#10;&#10;const property: Property = await api.getProperty(123)&#10;const agency: Agency = await api.getAgency(456)&#10;```&#10;&#10;## Supported Languages&#10;&#10;- English (`en`)&#10;- French (`fr`)&#10;&#10;More languages can be added based on Apimo API support.&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create your feature branch (`git checkout -b feature/amazing-feature`)&#10;3. Commit your changes (`git commit -m 'Add some amazing feature'`)&#10;4. Push to the branch (`git push origin feature/amazing-feature`)&#10;5. Open a Pull Request&#10;&#10;### Development&#10;&#10;```bash&#10;# Install dependencies&#10;yarn install&#10;&#10;# Run tests&#10;yarn test&#10;&#10;# Run tests with coverage&#10;yarn test-coverage&#10;&#10;# Run linting&#10;yarn lint&#10;&#10;# Build the package&#10;yarn build&#10;```&#10;&#10;## License&#10;&#10;MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;## Getting API Credentials&#10;&#10;To use this library, you need:&#10;&#10;1. **Bridge ID** - Your site identifier (string of numbers)&#10;2. **API Token** - Secret token for authentication&#10;&#10;Contact [Apimo customer service](https://apimo.net/en/contact/) to request your credentials.&#10;&#10;## Support&#10;&#10;-  [Apimo API Documentation](https://apimo.net/en/api/webservice/)&#10;-  [Issue Tracker](https://github.com/Neikow/apimo.js/issues)&#10;-  [Discussions](https://github.com/Neikow/apimo.js/discussions)&#10;&#10;---&#10;&#10;Made with ❤️ by [Vitaly Lysen](https://lysen.dev)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;apimo.js&quot;,&#10;  &quot;version&quot;: &quot;1.0.1&quot;,&#10;  &quot;description&quot;: &quot;A wrapper for the Apimo API with catalog caching for building custom Real Estate website using their technologies.&quot;,&#10;  &quot;main&quot;: &quot;/dist/index.js&quot;,&#10;  &quot;repository&quot;: {&#10;    &quot;type&quot;: &quot;git&quot;,&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js.git&quot;&#10;  },&#10;  &quot;homepage&quot;: &quot;https://github.com/Neikow/apimo.js&quot;,&#10;  &quot;bugs&quot;: {&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js/issues&quot;&#10;  },&#10;  &quot;keywords&quot;: [&#10;    &quot;api&quot;,&#10;    &quot;apimo&quot;,&#10;    &quot;real-estate&quot;&#10;  ],&#10;  &quot;scripts&quot;: {&#10;    &quot;dev&quot;: &quot;&quot;,&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;run&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;test&quot;: &quot;vitest run&quot;,&#10;    &quot;test-coverage&quot;: &quot;vitest run --coverage&quot;&#10;  },&#10;  &quot;author&quot;: &quot;Vitaly Lysen &lt;vitaly@lysen.dev&gt; (https://lysen.dev)&quot;,&#10;  &quot;license&quot;: &quot;MIT&quot;,&#10;  &quot;dependencies&quot;: {&#10;    &quot;bottleneck&quot;: &quot;^2.19.5&quot;,&#10;    &quot;merge-anything&quot;: &quot;^6.0.6&quot;,&#10;    &quot;zod&quot;: &quot;^3.21.4&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@antfu/eslint-config&quot;: &quot;^5.0.0&quot;,&#10;    &quot;@types/node&quot;: &quot;^24.1.0&quot;,&#10;    &quot;@anatine/zod-mock&quot;: &quot;^3.14.0&quot;,&#10;    &quot;@faker-js/faker&quot;: &quot;^9.9.0&quot;,&#10;    &quot;@vitest/coverage-v8&quot;: &quot;^3.2.4&quot;,&#10;    &quot;dotenv&quot;: &quot;^17.2.1&quot;,&#10;    &quot;eslint&quot;: &quot;^9.32.0&quot;,&#10;    &quot;typescript&quot;: &quot;^5.9.2&quot;,&#10;    &quot;vitest&quot;: &quot;^3.2.4&quot;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;apimo.js&quot;,&#10;  &quot;version&quot;: &quot;1.0.1&quot;,&#10;  &quot;description&quot;: &quot;A wrapper for the Apimo API with catalog caching for building custom Real Estate website using their technologies.&quot;,&#10;  &quot;main&quot;: &quot;/dist/index.js&quot;,&#10;  &quot;repository&quot;: {&#10;    &quot;type&quot;: &quot;git&quot;,&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js.git&quot;&#10;  },&#10;  &quot;homepage&quot;: &quot;https://github.com/Neikow/apimo.js&quot;,&#10;  &quot;bugs&quot;: {&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js/issues&quot;&#10;  },&#10;  &quot;keywords&quot;: [&#10;    &quot;api&quot;,&#10;    &quot;apimo&quot;,&#10;    &quot;real-estate&quot;&#10;  ],&#10;  &quot;scripts&quot;: {&#10;    &quot;dev&quot;: &quot;&quot;,&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;run&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;test&quot;: &quot;vitest run&quot;,&#10;    &quot;test-coverage&quot;: &quot;vitest run --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint .&quot;&#10;  },&#10;  &quot;author&quot;: &quot;Vitaly Lysen &lt;vitaly@lysen.dev&gt; (https://lysen.dev)&quot;,&#10;  &quot;license&quot;: &quot;MIT&quot;,&#10;  &quot;dependencies&quot;: {&#10;    &quot;bottleneck&quot;: &quot;^2.19.5&quot;,&#10;    &quot;merge-anything&quot;: &quot;^6.0.6&quot;,&#10;    &quot;zod&quot;: &quot;^3.21.4&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@antfu/eslint-config&quot;: &quot;^5.0.0&quot;,&#10;    &quot;@types/node&quot;: &quot;^24.1.0&quot;,&#10;    &quot;@anatine/zod-mock&quot;: &quot;^3.14.0&quot;,&#10;    &quot;@faker-js/faker&quot;: &quot;^9.9.0&quot;,&#10;    &quot;@vitest/coverage-v8&quot;: &quot;^3.2.4&quot;,&#10;    &quot;dotenv&quot;: &quot;^17.2.1&quot;,&#10;    &quot;eslint&quot;: &quot;^9.32.0&quot;,&#10;    &quot;typescript&quot;: &quot;^5.9.2&quot;,&#10;    &quot;vitest&quot;: &quot;^3.2.4&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts" />
              <option name="originalContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})&#10;" />
              <option name="updatedContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;&#10;  describe('behavior consistency', () =&gt; {&#10;    it('should behave consistently across multiple calls', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      // Multiple setEntries calls should not throw&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;&#10;      // Multiple getEntry calls should always throw&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should maintain dummy behavior regardless of cache state', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;&#10;      // Should throw before any operations&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after setting entries&#10;      await cache.setEntries(catalogName, culture, [{ id: 1, name: 'Test', name_plurial: 'Tests' }])&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after multiple operations&#10;      await cache.setEntries(catalogName, culture, [])&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>