<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/ci.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/ci.yml" />
              <option name="updatedContent" value="name: Continuous Integration&#10;&#10;on:&#10;  push:&#10;    branches: [ main, develop ]&#10;  pull_request:&#10;    branches: [ main, develop ]&#10;&#10;jobs:&#10;  test-and-lint:&#10;    runs-on: ubuntu-latest&#10;&#10;    strategy:&#10;      matrix:&#10;        node-version: [18, 20, 22]&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup Node.js ${{ matrix.node-version }}&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: ${{ matrix.node-version }}&#10;          cache: 'yarn'&#10;&#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;&#10;      - name: Run linting&#10;        run: yarn lint&#10;&#10;      - name: Run tests&#10;        run: yarn test&#10;&#10;      - name: Run test coverage&#10;        run: yarn test-coverage&#10;&#10;      - name: Upload coverage reports to Codecov&#10;        uses: codecov/codecov-action@v4&#10;        if: matrix.node-version == 20&#10;        with:&#10;          file: ./coverage/lcov.info&#10;          fail_ci_if_error: false&#10;        env:&#10;          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.github/workflows/publish.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/publish.yml" />
              <option name="originalContent" value="name: Build, Test &amp; Publish to NPM&#10;&#10;on:&#10;  push:&#10;    tags:&#10;      - 'v*'&#10;  workflow_dispatch:&#10;&#10;jobs:&#10;  test:&#10;    runs-on: ubuntu-latest&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup Node.js&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: '22'&#10;          cache: yarn&#10;&#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;&#10;      - name: Run linting&#10;        run: yarn lint&#10;&#10;      - name: Run tests&#10;        run: yarn test&#10;&#10;      - name: Run test coverage&#10;        run: yarn test-coverage&#10;&#10;  build-and-publish:&#10;    needs: test&#10;    runs-on: ubuntu-latest&#10;&#10;    environment: Deploy&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup Node.js&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: '22'&#10;          cache: yarn&#10;          registry-url: 'https://registry.npmjs.org'&#10;&#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;&#10;      - name: Build package&#10;        run: yarn build&#10;        &#10;      - name: Check build output&#10;        run: |&#10;          if [ ! -d &quot;dist&quot; ]; then&#10;            echo &quot;Build failed: dist directory not found&quot;&#10;            exit 1&#10;          fi&#10;          echo &quot;Build successful. Contents:&quot;&#10;          ls -la dist/&#10;          echo &quot;Checking for TypeScript definitions:&quot;&#10;          find dist -name &quot;*.d.ts&quot; | head -5&#10;          &#10;      - name: Clean workspace for publishing&#10;        run: |&#10;          # Remove development files and directories not needed for NPM&#10;          rm -rf src/&#10;          rm -rf coverage/&#10;          rm -rf cache/&#10;          rm -rf node_modules/&#10;          rm -rf .git/&#10;          rm -rf .github/&#10;          rm -rf .idea/&#10;          rm -f .env&#10;          rm -f .gitignore&#10;          rm -f eslint.config.mjs&#10;          rm -f tsconfig.json&#10;          rm -f vitest.config.ts&#10;          rm -f yarn.lock&#10;          echo &quot;Cleaned workspace. Remaining files:&quot;&#10;          ls -la&#10;          &#10;      - name: Publish to NPM&#10;        run: npm publish --access public&#10;        env:&#10;          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}&#10;" />
              <option name="updatedContent" value="name: Build, Test &amp; Publish to NPM&#10;&#10;on:&#10;  push:&#10;    tags:&#10;      - 'v*'&#10;  workflow_dispatch:&#10;&#10;jobs:&#10;  test:&#10;    runs-on: ubuntu-latest&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup Node.js&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: '22'&#10;          cache: yarn&#10;&#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;&#10;      - name: Run linting&#10;        run: yarn lint&#10;&#10;      - name: Run tests&#10;        run: yarn test&#10;&#10;      - name: Run test coverage&#10;        run: yarn test-coverage&#10;&#10;  build-and-publish:&#10;    needs: test&#10;    runs-on: ubuntu-latest&#10;&#10;    environment: Deploy&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup Node.js&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: '22'&#10;          cache: yarn&#10;          registry-url: 'https://registry.npmjs.org'&#10;&#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;&#10;      - name: Build package&#10;        run: yarn build&#10;        &#10;      - name: Check build output&#10;        run: |&#10;          if [ ! -d &quot;dist&quot; ]; then&#10;            echo &quot;Build failed: dist directory not found&quot;&#10;            exit 1&#10;          fi&#10;          echo &quot;Build successful. Contents:&quot;&#10;          ls -la dist/&#10;          echo &quot;Checking for TypeScript definitions:&quot;&#10;          find dist -name &quot;*.d.ts&quot; | head -5&#10;          &#10;      - name: Clean workspace for publishing&#10;        run: |&#10;          # Remove development files and directories not needed for NPM&#10;          rm -rf src/&#10;          rm -rf coverage/&#10;          rm -rf cache/&#10;          rm -rf node_modules/&#10;          rm -rf .git/&#10;          rm -rf .github/&#10;          rm -rf .idea/&#10;          rm -f .env&#10;          rm -f .gitignore&#10;          rm -f eslint.config.mjs&#10;          rm -f tsconfig.json&#10;          rm -f vitest.config.ts&#10;          rm -f yarn.lock&#10;          echo &quot;Cleaned workspace. Remaining files:&quot;&#10;          ls -la&#10;          &#10;      - name: Publish to NPM&#10;        run: npm publish --access public&#10;        env:&#10;          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Apimo.js&#10;&#10;[![npm version](https://badge.fury.io/js/apimo.js.svg)](https://badge.fury.io/js/apimo.js)&#10;[![CI](https://github.com/Neikow/apimo.js/actions/workflows/ci.yml/badge.svg)](https://github.com/Neikow/apimo.js/actions/workflows/ci.yml)&#10;[![codecov](https://codecov.io/gh/Neikow/apimo.js/branch/main/graph/badge.svg)](https://codecov.io/gh/Neikow/apimo.js)&#10;&#10;A comprehensive TypeScript wrapper for the [Apimo API](https://apimo.net/en/api/webservice/) with intelligent caching,&#10;rate limiting, and automatic catalog transformation for building custom Real Estate websites.&#10;&#10;## Features&#10;&#10;-  **TypeScript-first** - Full type safety with Zod schema validation&#10;-  **Smart Caching** - Multiple cache adapters (Memory, Filesystem, Dummy) with automatic invalidation&#10;-  **Rate Limiting** - Built-in request throttling to respect API limits (1000 requests/day)&#10;-  **Multi-language Support** - Automatic catalog transformation for localized content&#10;- ️ **Property &amp; Agency APIs** - Complete coverage of Apimo's real estate endpoints&#10;- ⚡ **Optimized Performance** - Intelligent catalog caching reduces API calls by 90%&#10;&#10;## Installation&#10;&#10;```bash&#10;npm install apimo.js&#10;# or&#10;yarn add apimo.js&#10;```&#10;&#10;## Quick Start&#10;&#10;```typescript&#10;import {Api} from 'apimo.js'&#10;&#10;const api = new Api(&#10;  'YOUR_BRIDGE_ID',     // Get from Apimo support&#10;  'YOUR_API_TOKEN',     // Get from Apimo support&#10;  {&#10;    culture: 'en',      // Default language&#10;    catalogs: {&#10;      cache: {&#10;        active: true,&#10;        adapter: new MemoryCache() // or FilesystemCache()&#10;      }&#10;    }&#10;  }&#10;)&#10;&#10;// Fetch properties with automatic catalog transformation&#10;const properties = await api.getProperties({&#10;  limit: 10,&#10;  offset: 0&#10;})&#10;&#10;// Get a specific property&#10;const property = await api.getProperty(123)&#10;&#10;// Fetch agencies&#10;const agencies = await api.getAgencies()&#10;```&#10;&#10;## Configuration&#10;&#10;### Basic Configuration&#10;&#10;```typescript&#10;const api = new Api(bridgeId, token, {&#10;  baseUrl: 'https://api.apimo.pro',  // API base URL&#10;  culture: 'en',                     // Default language (en, fr)&#10;  catalogs: {&#10;    cache: {&#10;      active: true,                  // Enable catalog caching&#10;      adapter: new MemoryCache()     // Cache implementation&#10;    },&#10;    transform: {&#10;      active: true,                  // Enable catalog transformation&#10;      transformFn: customTransformer // Optional custom transformer&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;### Cache Adapters&#10;&#10;#### Memory Cache (Default)&#10;&#10;```typescript&#10;import {MemoryCache} from 'apimo.js'&#10;&#10;const api = new Api(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new MemoryCache()&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;#### Filesystem Cache&#10;&#10;```typescript&#10;import {FilesystemCache} from 'apimo.js'&#10;&#10;const api = new Api(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new FilesystemCache('./cache')&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;#### Dummy Cache (No Caching)&#10;&#10;```typescript&#10;import {DummyCache} from 'apimo.js'&#10;&#10;const api = new Api(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new DummyCache()&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;## API Reference&#10;&#10;### Properties&#10;&#10;#### `getProperties(options?)`&#10;&#10;Fetch a list of properties with optional filtering.&#10;&#10;```typescript&#10;const properties = await api.getProperties({&#10;  limit: 20,&#10;  offset: 0,&#10;  culture: 'fr',&#10;  // Add property filters as needed&#10;})&#10;```&#10;&#10;#### `getProperty(id, options?)`&#10;&#10;Fetch a specific property by ID.&#10;&#10;```typescript&#10;const property = await api.getProperty(123, {&#10;  culture: 'en'&#10;})&#10;```&#10;&#10;### Agencies&#10;&#10;#### `getAgencies(options?)`&#10;&#10;Fetch a list of agencies.&#10;&#10;```typescript&#10;const agencies = await api.getAgencies({&#10;  limit: 10,&#10;  culture: 'fr'&#10;})&#10;```&#10;&#10;#### `getAgency(id, options?)`&#10;&#10;Fetch a specific agency by ID.&#10;&#10;```typescript&#10;const agency = await api.getAgency(456)&#10;```&#10;&#10;### Catalogs&#10;&#10;#### `fetchCatalogs()`&#10;&#10;Get all available catalog definitions.&#10;&#10;```typescript&#10;const catalogs = await api.fetchCatalogs()&#10;```&#10;&#10;#### `fetchCatalog(catalogName, options?)`&#10;&#10;Fetch entries for a specific catalog.&#10;&#10;```typescript&#10;const propertyTypes = await api.fetchCatalog('property_type', {&#10;  culture: 'en'&#10;})&#10;```&#10;&#10;#### `getCatalogEntries(catalogName, options?)`&#10;&#10;Get catalog entries from cache (populates cache if needed).&#10;&#10;```typescript&#10;const entries = await api.getCatalogEntries('property_category', {&#10;  culture: 'fr'&#10;})&#10;```&#10;&#10;### Low-level API&#10;&#10;#### `get(path, schema, options?)`&#10;&#10;Make a direct API call with schema validation.&#10;&#10;```typescript&#10;import {z} from 'zod'&#10;&#10;const customSchema = z.object({&#10;  id: z.number(),&#10;  name: z.string()&#10;})&#10;&#10;const result = await api.get(['custom', 'endpoint'], customSchema, {&#10;  culture: 'en',&#10;  limit: 10&#10;})&#10;```&#10;&#10;#### `fetch(...args)`&#10;&#10;Direct fetch with automatic authentication headers.&#10;&#10;```typescript&#10;const response = await api.fetch('https://api.apimo.pro/properties')&#10;```&#10;&#10;## Data Transformation&#10;&#10;Apimo.js automatically transforms catalog IDs into human-readable names:&#10;&#10;```typescript&#10;// Raw API response&#10;{&#10;  &quot;type&quot;&#10;:&#10;  1,&#10;    &quot;category&quot;&#10;:&#10;  2&#10;}&#10;&#10;// Transformed response&#10;{&#10;  &quot;type&quot;&#10;:&#10;  &quot;House&quot;,&#10;    &quot;category&quot;&#10;:&#10;  &quot;Sale&quot;&#10;}&#10;```&#10;&#10;### Custom Transformers&#10;&#10;```typescript&#10;const customTransformer = async (catalogName, culture, id) =&gt; {&#10;  // Your custom transformation logic&#10;  return await myCustomCatalogLookup(catalogName, culture, id)&#10;}&#10;&#10;const api = new Api(bridgeId, token, {&#10;  catalogs: {&#10;    transform: {&#10;      active: true,&#10;      transformFn: customTransformer&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;## Rate Limiting&#10;&#10;The library includes built-in rate limiting to respect Apimo's API limits:&#10;&#10;- **10 requests per second** (configurable)&#10;- **Automatic queuing** of excess requests&#10;- **Bottleneck integration** for advanced rate limiting scenarios&#10;&#10;## Error Handling&#10;&#10;```typescript&#10;try {&#10;  const properties = await api.getProperties()&#10;} catch (error) {&#10;  if (error instanceof CacheExpiredError) {&#10;    // Handle cache expiration&#10;  } else {&#10;    // Handle other API errors&#10;    console.error('API Error:', error.message)&#10;  }&#10;}&#10;```&#10;&#10;## TypeScript Support&#10;&#10;Full TypeScript support with comprehensive type definitions:&#10;&#10;```typescript&#10;import type {Property, Agency, CatalogEntry} from 'apimo.js'&#10;&#10;const property: Property = await api.getProperty(123)&#10;const agency: Agency = await api.getAgency(456)&#10;```&#10;&#10;## Supported Languages&#10;&#10;- English (`en`)&#10;- French (`fr`)&#10;&#10;More languages can be added based on Apimo API support.&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create your feature branch (`git checkout -b feature/amazing-feature`)&#10;3. Commit your changes (`git commit -m 'Add some amazing feature'`)&#10;4. Push to the branch (`git push origin feature/amazing-feature`)&#10;5. Open a Pull Request&#10;&#10;### Development&#10;&#10;```bash&#10;# Install dependencies&#10;yarn install&#10;&#10;# Run tests&#10;yarn test&#10;&#10;# Run tests with coverage&#10;yarn test-coverage&#10;&#10;# Run linting&#10;yarn lint&#10;&#10;# Build the package&#10;yarn build&#10;```&#10;&#10;## License&#10;&#10;MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;## Getting API Credentials&#10;&#10;To use this library, you need:&#10;&#10;1. **Bridge ID** - Your site identifier (string of numbers)&#10;2. **API Token** - Secret token for authentication&#10;&#10;Contact [Apimo customer service](https://apimo.net/en/contact/) to request your credentials.&#10;&#10;## Support&#10;&#10;-  [Apimo API Documentation](https://apimo.net/en/api/webservice/)&#10;-  [Issue Tracker](https://github.com/Neikow/apimo.js/issues)&#10;-  [Discussions](https://github.com/Neikow/apimo.js/discussions)&#10;&#10;---&#10;&#10;Made with ❤️ by [Vitaly Lysen](https://lysen.dev)&#10;" />
              <option name="updatedContent" value="# Apimo.js&#10;&#10;[![npm version](https://badge.fury.io/js/apimo.js.svg)](https://badge.fury.io/js/apimo.js)&#10;[![CI](https://github.com/Neikow/apimo.js/actions/workflows/ci.yml/badge.svg)](https://github.com/Neikow/apimo.js/actions/workflows/ci.yml)&#10;[![codecov](https://codecov.io/gh/Neikow/apimo.js/branch/main/graph/badge.svg)](https://codecov.io/gh/Neikow/apimo.js)&#10;&#10;A comprehensive TypeScript wrapper for the [Apimo API](https://apimo.net/en/api/webservice/) with intelligent caching,&#10;rate limiting, and automatic catalog transformation for building custom Real Estate websites.&#10;&#10;## Features&#10;&#10;-  **TypeScript-first** - Full type safety with Zod schema validation&#10;-  **Smart Caching** - Multiple cache adapters (Memory, Filesystem, Dummy) with automatic invalidation&#10;-  **Rate Limiting** - Built-in request throttling to respect API limits (1000 requests/day)&#10;-  **Multi-language Support** - Automatic catalog transformation for localized content&#10;- ️ **Property &amp; Agency APIs** - Complete coverage of Apimo's real estate endpoints&#10;- ⚡ **Optimized Performance** - Intelligent catalog caching reduces API calls by 90%&#10;&#10;## Installation&#10;&#10;```bash&#10;npm install apimo.js&#10;# or&#10;yarn add apimo.js&#10;```&#10;&#10;## Quick Start&#10;&#10;```typescript&#10;import { Apimo } from 'apimo.js'&#10;&#10;const api = new Apimo(&#10;  'YOUR_BRIDGE_ID',     // Get from Apimo support&#10;  'YOUR_API_TOKEN',     // Get from Apimo support&#10;  {&#10;    culture: 'en',      // Default language&#10;    catalogs: {&#10;      cache: {&#10;        active: true,&#10;        adapter: new MemoryCache() // or FilesystemCache()&#10;      }&#10;    }&#10;  }&#10;)&#10;&#10;// Fetch properties with automatic catalog transformation&#10;const properties = await api.getProperties({&#10;  limit: 10,&#10;  offset: 0&#10;})&#10;&#10;// Get a specific property&#10;const property = await api.getProperty(123)&#10;&#10;// Fetch agencies&#10;const agencies = await api.getAgencies()&#10;```&#10;&#10;## Configuration&#10;&#10;### Basic Configuration&#10;&#10;```typescript&#10;const api = new Apimo(bridgeId, token, {&#10;  baseUrl: 'https://api.apimo.pro',  // API base URL&#10;  culture: 'en',                     // Default language (en, fr)&#10;  catalogs: {&#10;    cache: {&#10;      active: true,                  // Enable catalog caching&#10;      adapter: new MemoryCache()     // Cache implementation&#10;    },&#10;    transform: {&#10;      active: true,                  // Enable catalog transformation&#10;      transformFn: customTransformer // Optional custom transformer&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;### Cache Adapters&#10;&#10;#### Memory Cache (Default)&#10;&#10;```typescript&#10;import { MemoryCache } from 'apimo.js'&#10;&#10;const api = new Apimo(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new MemoryCache()&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;#### Filesystem Cache&#10;&#10;```typescript&#10;import { FilesystemCache } from 'apimo.js'&#10;&#10;const api = new Apimo(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new FilesystemCache('./cache')&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;#### Dummy Cache (No Caching)&#10;&#10;```typescript&#10;import { DummyCache } from 'apimo.js'&#10;&#10;const api = new Apimo(bridgeId, token, {&#10;  catalogs: {&#10;    cache: {&#10;      adapter: new DummyCache()&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;## API Reference&#10;&#10;### Properties&#10;&#10;#### `getProperties(options?)`&#10;&#10;Fetch a list of properties with optional filtering.&#10;&#10;```typescript&#10;const properties = await api.getProperties({&#10;  limit: 20,&#10;  offset: 0,&#10;  culture: 'fr',&#10;  // Add property filters as needed&#10;})&#10;```&#10;&#10;#### `getProperty(id, options?)`&#10;&#10;Fetch a specific property by ID.&#10;&#10;```typescript&#10;const property = await api.getProperty(123, {&#10;  culture: 'en'&#10;})&#10;```&#10;&#10;### Agencies&#10;&#10;#### `getAgencies(options?)`&#10;&#10;Fetch a list of agencies.&#10;&#10;```typescript&#10;const agencies = await api.getAgencies({&#10;  limit: 10,&#10;  culture: 'fr'&#10;})&#10;```&#10;&#10;#### `getAgency(id, options?)`&#10;&#10;Fetch a specific agency by ID.&#10;&#10;```typescript&#10;const agency = await api.getAgency(456)&#10;```&#10;&#10;### Catalogs&#10;&#10;#### `fetchCatalogs()`&#10;&#10;Get all available catalog definitions.&#10;&#10;```typescript&#10;const catalogs = await api.fetchCatalogs()&#10;```&#10;&#10;#### `fetchCatalog(catalogName, options?)`&#10;&#10;Fetch entries for a specific catalog.&#10;&#10;```typescript&#10;const propertyTypes = await api.fetchCatalog('property_type', {&#10;  culture: 'en'&#10;})&#10;```&#10;&#10;#### `getCatalogEntries(catalogName, options?)`&#10;&#10;Get catalog entries from cache (populates cache if needed).&#10;&#10;```typescript&#10;const entries = await api.getCatalogEntries('property_category', {&#10;  culture: 'fr'&#10;})&#10;```&#10;&#10;### Low-level API&#10;&#10;#### `get(path, schema, options?)`&#10;&#10;Make a direct API call with schema validation.&#10;&#10;```typescript&#10;import {z} from 'zod'&#10;&#10;const customSchema = z.object({&#10;  id: z.number(),&#10;  name: z.string()&#10;})&#10;&#10;const result = await api.get(['custom', 'endpoint'], customSchema, {&#10;  culture: 'en',&#10;  limit: 10&#10;})&#10;```&#10;&#10;#### `fetch(...args)`&#10;&#10;Direct fetch with automatic authentication headers.&#10;&#10;```typescript&#10;const response = await api.fetch('https://api.apimo.pro/properties')&#10;```&#10;&#10;## Data Transformation&#10;&#10;Apimo.js automatically transforms catalog IDs into human-readable names:&#10;&#10;```typescript&#10;// Raw API response&#10;{&#10;  &quot;type&quot;&#10;:&#10;  1,&#10;    &quot;category&quot;&#10;:&#10;  2&#10;}&#10;&#10;// Transformed response&#10;{&#10;  &quot;type&quot;&#10;:&#10;  &quot;House&quot;,&#10;    &quot;category&quot;&#10;:&#10;  &quot;Sale&quot;&#10;}&#10;```&#10;&#10;### Custom Transformers&#10;&#10;```typescript&#10;const customTransformer = async (catalogName, culture, id) =&gt; {&#10;  // Your custom transformation logic&#10;  return await myCustomCatalogLookup(catalogName, culture, id)&#10;}&#10;&#10;const api = new Apimo(bridgeId, token, {&#10;  catalogs: {&#10;    transform: {&#10;      active: true,&#10;      transformFn: customTransformer&#10;    }&#10;  }&#10;})&#10;```&#10;&#10;## Rate Limiting&#10;&#10;The library includes built-in rate limiting to respect Apimo's API limits:&#10;&#10;- **10 requests per second** (configurable)&#10;- **Automatic queuing** of excess requests&#10;- **Bottleneck integration** for advanced rate limiting scenarios&#10;&#10;## Error Handling&#10;&#10;```typescript&#10;try {&#10;  const properties = await api.getProperties()&#10;} catch (error) {&#10;  if (error instanceof CacheExpiredError) {&#10;    // Handle cache expiration&#10;  } else {&#10;    // Handle other API errors&#10;    console.error('API Error:', error.message)&#10;  }&#10;}&#10;```&#10;&#10;## TypeScript Support&#10;&#10;Full TypeScript support with comprehensive type definitions:&#10;&#10;```typescript&#10;import type {Property, Agency, CatalogEntry} from 'apimo.js'&#10;&#10;const property: Property = await api.getProperty(123)&#10;const agency: Agency = await api.getAgency(456)&#10;```&#10;&#10;## Supported Languages&#10;&#10;- English (`en`)&#10;- French (`fr`)&#10;&#10;More languages can be added based on Apimo API support.&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create your feature branch (`git checkout -b feature/amazing-feature`)&#10;3. Commit your changes (`git commit -m 'Add some amazing feature'`)&#10;4. Push to the branch (`git push origin feature/amazing-feature`)&#10;5. Open a Pull Request&#10;&#10;### Development&#10;&#10;```bash&#10;# Install dependencies&#10;yarn install&#10;&#10;# Run tests&#10;yarn test&#10;&#10;# Run tests with coverage&#10;yarn test-coverage&#10;&#10;# Run linting&#10;yarn lint&#10;&#10;# Build the package&#10;yarn build&#10;```&#10;&#10;## License&#10;&#10;MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;## Getting API Credentials&#10;&#10;To use this library, you need:&#10;&#10;1. **Bridge ID** - Your site identifier (string of numbers)&#10;2. **API Token** - Secret token for authentication&#10;&#10;Contact [Apimo customer service](https://apimo.net/en/contact/) to request your credentials.&#10;&#10;## Support&#10;&#10;-  [Apimo API Documentation](https://apimo.net/en/api/webservice/)&#10;-  [Issue Tracker](https://github.com/Neikow/apimo.js/issues)&#10;-  [Discussions](https://github.com/Neikow/apimo.js/discussions)&#10;&#10;---&#10;&#10;Made with ❤️ by [Vitaly Lysen](https://lysen.dev)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;apimo.js&quot;,&#10;  &quot;version&quot;: &quot;1.0.1&quot;,&#10;  &quot;description&quot;: &quot;A wrapper for the Apimo API with catalog caching for building custom Real Estate website using their technologies.&quot;,&#10;  &quot;author&quot;: &quot;Vitaly Lysen &lt;vitaly@lysen.dev&gt; (https://lysen.dev)&quot;,&#10;  &quot;license&quot;: &quot;MIT&quot;,&#10;  &quot;homepage&quot;: &quot;https://github.com/Neikow/apimo.js&quot;,&#10;  &quot;repository&quot;: {&#10;    &quot;type&quot;: &quot;git&quot;,&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js.git&quot;&#10;  },&#10;  &quot;bugs&quot;: {&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js/issues&quot;&#10;  },&#10;  &quot;keywords&quot;: [&#10;    &quot;api&quot;,&#10;    &quot;apimo&quot;,&#10;    &quot;real-estate&quot;&#10;  ],&#10;  &quot;main&quot;: &quot;/dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;dev&quot;: &quot;&quot;,&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;run&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;test&quot;: &quot;vitest run&quot;,&#10;    &quot;test-coverage&quot;: &quot;vitest run --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint .&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;bottleneck&quot;: &quot;^2.19.5&quot;,&#10;    &quot;merge-anything&quot;: &quot;^6.0.6&quot;,&#10;    &quot;zod&quot;: &quot;^3.21.4&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@anatine/zod-mock&quot;: &quot;^3.14.0&quot;,&#10;    &quot;@antfu/eslint-config&quot;: &quot;^5.0.0&quot;,&#10;    &quot;@faker-js/faker&quot;: &quot;^9.9.0&quot;,&#10;    &quot;@types/node&quot;: &quot;^24.1.0&quot;,&#10;    &quot;@vitest/coverage-v8&quot;: &quot;^3.2.4&quot;,&#10;    &quot;dotenv&quot;: &quot;^17.2.1&quot;,&#10;    &quot;eslint&quot;: &quot;^9.32.0&quot;,&#10;    &quot;typescript&quot;: &quot;^5.9.2&quot;,&#10;    &quot;vitest&quot;: &quot;^3.2.4&quot;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;apimo.js&quot;,&#10;  &quot;version&quot;: &quot;1.0.1&quot;,&#10;  &quot;description&quot;: &quot;A wrapper for the Apimo API with catalog caching for building custom Real Estate website using their technologies.&quot;,&#10;  &quot;main&quot;: &quot;./dist/index.js&quot;,&#10;  &quot;types&quot;: &quot;./dist/index.d.ts&quot;,&#10;  &quot;module&quot;: &quot;./dist/index.js&quot;,&#10;  &quot;exports&quot;: {&#10;    &quot;.&quot;: {&#10;      &quot;import&quot;: &quot;./dist/index.js&quot;,&#10;      &quot;require&quot;: &quot;./dist/index.js&quot;,&#10;      &quot;types&quot;: &quot;./dist/index.d.ts&quot;&#10;    }&#10;  },&#10;  &quot;files&quot;: [&#10;    &quot;dist/**/*&quot;,&#10;    &quot;README.md&quot;,&#10;    &quot;LICENSE&quot;&#10;  ],&#10;  &quot;repository&quot;: {&#10;    &quot;type&quot;: &quot;git&quot;,&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js.git&quot;&#10;  },&#10;  &quot;homepage&quot;: &quot;https://github.com/Neikow/apimo.js&quot;,&#10;  &quot;bugs&quot;: {&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js/issues&quot;&#10;  },&#10;  &quot;keywords&quot;: [&#10;    &quot;api&quot;,&#10;    &quot;apimo&quot;,&#10;    &quot;real-estate&quot;&#10;  ],&#10;  &quot;scripts&quot;: {&#10;    &quot;dev&quot;: &quot;&quot;,&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;run&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;test&quot;: &quot;vitest run&quot;,&#10;    &quot;test-coverage&quot;: &quot;vitest run --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint .&quot;&#10;  },&#10;  &quot;author&quot;: &quot;Vitaly Lysen &lt;vitaly@lysen.dev&gt; (https://lysen.dev)&quot;,&#10;  &quot;license&quot;: &quot;MIT&quot;,&#10;  &quot;dependencies&quot;: {&#10;    &quot;bottleneck&quot;: &quot;^2.19.5&quot;,&#10;    &quot;merge-anything&quot;: &quot;^6.0.6&quot;,&#10;    &quot;zod&quot;: &quot;^3.21.4&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@antfu/eslint-config&quot;: &quot;^5.0.0&quot;,&#10;    &quot;@types/node&quot;: &quot;^24.1.0&quot;,&#10;    &quot;@anatine/zod-mock&quot;: &quot;^3.14.0&quot;,&#10;    &quot;@faker-js/faker&quot;: &quot;^9.9.0&quot;,&#10;    &quot;@vitest/coverage-v8&quot;: &quot;^3.2.4&quot;,&#10;    &quot;dotenv&quot;: &quot;^17.2.1&quot;,&#10;    &quot;eslint&quot;: &quot;^9.32.0&quot;,&#10;    &quot;typescript&quot;: &quot;^5.9.2&quot;,&#10;    &quot;vitest&quot;: &quot;^3.2.4&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/api.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/api.ts" />
              <option name="originalContent" value="import type { CatalogName } from '../consts/catalogs'&#10;import type { ApiCulture } from '../consts/languages'&#10;import type { CatalogDefinition, CatalogEntry, CatalogTransformer, LocalizedCatalogTransformer } from '../schemas/common'&#10;import type { ApiCacheAdapter, CatalogEntryName } from '../services/storage/types'&#10;import type { DeepPartial } from '../types'&#10;import type { ApiSearchParams } from '../utils/url'&#10;import Bottleneck from 'bottleneck'&#10;import { merge } from 'merge-anything'&#10;import { z } from 'zod'&#10;import { getAgencySchema } from '../schemas/agency'&#10;import { CatalogDefinitionSchema, CatalogEntrySchema } from '../schemas/common'&#10;import { getPropertySchema } from '../schemas/property'&#10;import { DummyCache } from '../services/storage/dummy.cache'&#10;import { MemoryCache } from '../services/storage/memory.cache'&#10;import { CacheExpiredError } from '../services/storage/types'&#10;import { makeApiUrl } from '../utils/url'&#10;&#10;/**&#10; * ApiConfig&#10; * ---&#10; *&#10; * The general config, used to create an API wrapper. It exports major endpoints as methods.&#10; * Internally, it's a simple wrapper to node:fetch with a neater syntax.&#10; */&#10;export interface AdditionalConfig {&#10;  // Base path for API access. Defaults to &quot;https://api.apimo.pro/&quot;.&#10;  baseUrl: string&#10;  // The default language to use when none is provided. Translates to &quot;culture&quot; in the API.&#10;  culture: ApiCulture&#10;  // Catalog related configuration&#10;  catalogs: {&#10;    // Caching of catalogs, for faster transformation&#10;    cache: {&#10;      // Whether to use the catalog caching. A value of false means that catalogs won't be cached. You will need to supply your own `catalogs.transform.transformFn`.&#10;      active: boolean&#10;      // Where to store the catalogs cache. Currently only file is supported.&#10;      adapter: ApiCacheAdapter&#10;    }&#10;    // Catalog transformation related configuration&#10;    transform: {&#10;      // Whether to use the catalog transformation. A value of false will apply an identity function to the catalog ids.&#10;      active: boolean&#10;      // If provided, the function that will replace the default catalog transformer function.&#10;      transformFn?: CatalogTransformer&#10;    }&#10;  }&#10;}&#10;&#10;export const DEFAULT_BASE_URL = 'https://api.apimo.pro'&#10;&#10;export const DEFAULT_ADDITIONAL_CONFIG: AdditionalConfig = {&#10;  baseUrl: DEFAULT_BASE_URL,&#10;  culture: 'en',&#10;  catalogs: {&#10;    cache: {&#10;      active: true,&#10;      adapter: new MemoryCache(),&#10;    },&#10;    transform: {&#10;      active: true,&#10;    },&#10;  },&#10;}&#10;&#10;export class Apimo {&#10;  readonly config: AdditionalConfig&#10;  readonly cache: ApiCacheAdapter&#10;  readonly limiter: Bottleneck&#10;&#10;  constructor(&#10;    // The site identifier, in a string of numbers format. You can request yours by contacting Apimo.net customer service.&#10;    private readonly provider: string,&#10;    // The secret token for API authentication&#10;    private readonly token: string,&#10;    // Additional config, to tweak how the API is handled&#10;    config: DeepPartial&lt;AdditionalConfig&gt; = DEFAULT_ADDITIONAL_CONFIG,&#10;  ) {&#10;    this.config = merge(DEFAULT_ADDITIONAL_CONFIG, config) as AdditionalConfig&#10;    this.cache = this.config.catalogs.cache.active ? this.config.catalogs.cache.adapter : new DummyCache()&#10;    this.limiter = new Bottleneck({&#10;      reservoir: 10,&#10;      reservoirRefreshAmount: 10,&#10;      reservoirRefreshInterval: 1000,&#10;    })&#10;  }&#10;&#10;  /**&#10;   * An override of fetch that adds the required Authorization header to every request.&#10;   */&#10;  public fetch(...parameters: Parameters&lt;typeof fetch&gt;): Promise&lt;Response&gt; {&#10;    const [input, init] = parameters&#10;    const extendedInit: RequestInit = {&#10;      ...init,&#10;      headers: {&#10;        Authorization: `Basic ${btoa(`${this.provider}:${this.token}`)}`,&#10;        ...init?.headers,&#10;      },&#10;    }&#10;&#10;    return this.limiter.schedule(() =&gt; fetch(input, extendedInit))&#10;  }&#10;&#10;  public async get&lt;S extends z.Schema&gt;(path: string[], schema: S, options?: Partial&lt;ApiSearchParams&gt;): Promise&lt;z.infer&lt;S&gt;&gt; {&#10;    const response = await this.fetch(&#10;      makeApiUrl(path, this.config, {&#10;        culture: this.config.culture,&#10;        ...options,&#10;      }),&#10;    )&#10;&#10;    if (!response.ok) {&#10;      throw new Error(await response.json())&#10;    }&#10;&#10;    return schema.parseAsync(await response.json())&#10;  }&#10;&#10;  public async fetchCatalogs(): Promise&lt;CatalogDefinition[]&gt; {&#10;    return this.get(&#10;      ['catalogs'],&#10;      z.array(CatalogDefinitionSchema),&#10;    )&#10;  }&#10;&#10;  public async populateCache(catalogName: CatalogName, culture: ApiCulture): Promise&lt;void&gt;&#10;  public async populateCache(catalogName: CatalogName, culture: ApiCulture, id: number): Promise&lt;CatalogEntryName | null&gt;&#10;  public async populateCache(catalogName: CatalogName, culture: ApiCulture, id?: number): Promise&lt;void | CatalogEntryName | null&gt; {&#10;    const catalog = await this.fetchCatalog(&#10;      catalogName,&#10;      { culture },&#10;    )&#10;    await this.cache.setEntries(&#10;      catalogName,&#10;      culture,&#10;      catalog,&#10;    )&#10;&#10;    if (id !== undefined) {&#10;      const queriedKey = catalog.find(({ id: entryId }) =&gt; entryId === id)&#10;      return queriedKey&#10;        ? {&#10;            name: queriedKey.name,&#10;            namePlural: queriedKey.name_plurial,&#10;          }&#10;        : null&#10;    }&#10;  }&#10;&#10;  public async getCatalogEntries(catalogName: CatalogName, options?: Pick&lt;ApiSearchParams, 'culture'&gt;): Promise&lt;CatalogEntry[]&gt; {&#10;    try {&#10;      return await this.cache.getEntries(catalogName, options?.culture ?? this.config.culture)&#10;    }&#10;    catch (e) {&#10;      if (e instanceof CacheExpiredError) {&#10;        await this.populateCache(catalogName, options?.culture ?? this.config.culture)&#10;        return this.cache.getEntries(catalogName, options?.culture ?? this.config.culture)&#10;      }&#10;      else {&#10;        throw e&#10;      }&#10;    }&#10;  }&#10;&#10;  public async fetchCatalog(catalogName: CatalogName, options?: Pick&lt;ApiSearchParams, 'culture'&gt;): Promise&lt;CatalogEntry[]&gt; {&#10;    return this.get(&#10;      ['catalogs', catalogName],&#10;      z.array(CatalogEntrySchema),&#10;      options,&#10;    )&#10;  }&#10;&#10;  public async fetchAgencies(options?: Pick&lt;ApiSearchParams, 'culture' | 'limit' | 'offset'&gt;) {&#10;    return this.get(&#10;      ['agencies'],&#10;      z.object({&#10;        total_items: z.number(),&#10;        agencies: getAgencySchema(this.getLocalizedCatalogTransformer(&#10;          options?.culture ?? this.config.culture,&#10;        ), this.config).array(),&#10;        timestamp: z.number(),&#10;      },&#10;      ),&#10;    )&#10;  }&#10;&#10;  public async fetchProperties(agencyId: number, options?: Pick&lt;ApiSearchParams, 'culture' | 'limit' | 'offset' | 'timestamp' | 'step' | 'status' | 'group'&gt;) {&#10;    return this.get(&#10;      ['agencies', agencyId.toString(), 'properties'],&#10;      z.object({&#10;        total_items: z.number(),&#10;        timestamp: z.number(),&#10;        properties: getPropertySchema(this.getLocalizedCatalogTransformer(&#10;          options?.culture ?? this.config.culture,&#10;        )).array(),&#10;      }),&#10;      options,&#10;    )&#10;  }&#10;&#10;  private getLocalizedCatalogTransformer(culture: ApiCulture): LocalizedCatalogTransformer {&#10;    return async (catalogName, id) =&gt; {&#10;      if (!this.config.catalogs.transform.active) {&#10;        return `${catalogName}.${id}`&#10;      }&#10;      if (this.config.catalogs.transform.transformFn) {&#10;        return this.config.catalogs.transform.transformFn(&#10;          catalogName,&#10;          culture,&#10;          id,&#10;        )&#10;      }&#10;&#10;      return this.catalogTransformer(catalogName, culture, id)&#10;    }&#10;  }&#10;&#10;  private async catalogTransformer(catalogName: CatalogName, culture: ApiCulture, id: number): Promise&lt;CatalogEntryName | null&gt; {&#10;    try {&#10;      return await this.cache.getEntry(catalogName, culture, id)&#10;    }&#10;    catch (e) {&#10;      if (e instanceof CacheExpiredError) {&#10;        return await this.populateCache(catalogName, culture, id)&#10;      }&#10;      else {&#10;        throw e&#10;      }&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import type { CatalogName } from '../consts/catalogs'&#10;import type { ApiCulture } from '../consts/languages'&#10;import type { CatalogDefinition, CatalogEntry, CatalogTransformer, LocalizedCatalogTransformer } from '../schemas/common'&#10;import type { ApiCacheAdapter, CatalogEntryName } from '../services/storage/types'&#10;import type { DeepPartial } from '../types'&#10;import type { ApiSearchParams } from '../utils/url'&#10;import Bottleneck from 'bottleneck'&#10;import { merge } from 'merge-anything'&#10;import { z } from 'zod'&#10;import { getAgencySchema } from '../schemas/agency'&#10;import { CatalogDefinitionSchema, CatalogEntrySchema } from '../schemas/common'&#10;import { getPropertySchema } from '../schemas/property'&#10;import { DummyCache } from '../services/storage/dummy.cache'&#10;import { MemoryCache } from '../services/storage/memory.cache'&#10;import { CacheExpiredError } from '../services/storage/types'&#10;import { makeApiUrl } from '../utils/url'&#10;&#10;/**&#10; * ApiConfig&#10; * ---&#10; *&#10; * The general config, used to create an API wrapper. It exports major endpoints as methods.&#10; * Internally, it's a simple wrapper to node:fetch with a neater syntax.&#10; */&#10;export interface AdditionalConfig {&#10;  // Base path for API access. Defaults to &quot;https://api.apimo.pro/&quot;.&#10;  baseUrl: string&#10;  // The default language to use when none is provided. Translates to &quot;culture&quot; in the API.&#10;  culture: ApiCulture&#10;  // Catalog related configuration&#10;  catalogs: {&#10;    // Caching of catalogs, for faster transformation&#10;    cache: {&#10;      // Whether to use the catalog caching. A value of false means that catalogs won't be cached. You will need to supply your own `catalogs.transform.transformFn`.&#10;      active: boolean&#10;      // Where to store the catalogs cache. Currently only file is supported.&#10;      adapter: ApiCacheAdapter&#10;    }&#10;    // Catalog transformation related configuration&#10;    transform: {&#10;      // Whether to use the catalog transformation. A value of false will apply an identity function to the catalog ids.&#10;      active: boolean&#10;      // If provided, the function that will replace the default catalog transformer function.&#10;      transformFn?: CatalogTransformer&#10;    }&#10;  }&#10;}&#10;&#10;export const DEFAULT_BASE_URL = 'https://api.apimo.pro'&#10;&#10;export const DEFAULT_ADDITIONAL_CONFIG: AdditionalConfig = {&#10;  baseUrl: DEFAULT_BASE_URL,&#10;  culture: 'en',&#10;  catalogs: {&#10;    cache: {&#10;      active: true,&#10;      adapter: new MemoryCache(),&#10;    },&#10;    transform: {&#10;      active: true,&#10;    },&#10;  },&#10;}&#10;&#10;export class Apimo {&#10;  readonly config: AdditionalConfig&#10;  readonly cache: ApiCacheAdapter&#10;  readonly limiter: Bottleneck&#10;&#10;  constructor(&#10;    // The site identifier, in a string of numbers format. You can request yours by contacting Apimo.net customer service.&#10;    private readonly provider: string,&#10;    // The secret token for API authentication&#10;    private readonly token: string,&#10;    // Additional config, to tweak how the API is handled&#10;    config: DeepPartial&lt;AdditionalConfig&gt; = DEFAULT_ADDITIONAL_CONFIG,&#10;  ) {&#10;    this.config = merge(DEFAULT_ADDITIONAL_CONFIG, config) as AdditionalConfig&#10;    this.cache = this.config.catalogs.cache.active ? this.config.catalogs.cache.adapter : new DummyCache()&#10;    this.limiter = new Bottleneck({&#10;      reservoir: 10,&#10;      reservoirRefreshAmount: 10,&#10;      reservoirRefreshInterval: 1000,&#10;    })&#10;  }&#10;&#10;  /**&#10;   * An override of fetch that adds the required Authorization header to every request.&#10;   */&#10;  public fetch(...parameters: Parameters&lt;typeof fetch&gt;): Promise&lt;Response&gt; {&#10;    const [input, init] = parameters&#10;    const extendedInit: RequestInit = {&#10;      ...init,&#10;      headers: {&#10;        Authorization: `Basic ${btoa(`${this.provider}:${this.token}`)}`,&#10;        ...init?.headers,&#10;      },&#10;    }&#10;&#10;    return this.limiter.schedule(() =&gt; fetch(input, extendedInit))&#10;  }&#10;&#10;  public async get&lt;S extends z.Schema&gt;(path: string[], schema: S, options?: Partial&lt;ApiSearchParams&gt;): Promise&lt;z.infer&lt;S&gt;&gt; {&#10;    const response = await this.fetch(&#10;      makeApiUrl(path, this.config, {&#10;        culture: this.config.culture,&#10;        ...options,&#10;      }),&#10;    )&#10;&#10;    if (!response.ok) {&#10;      throw new Error(await response.json())&#10;    }&#10;&#10;    return schema.parseAsync(await response.json())&#10;  }&#10;&#10;  public async fetchCatalogs(): Promise&lt;CatalogDefinition[]&gt; {&#10;    return this.get(&#10;      ['catalogs'],&#10;      z.array(CatalogDefinitionSchema),&#10;    )&#10;  }&#10;&#10;  public async populateCache(catalogName: CatalogName, culture: ApiCulture): Promise&lt;void&gt;&#10;  public async populateCache(catalogName: CatalogName, culture: ApiCulture, id: number): Promise&lt;CatalogEntryName | null&gt;&#10;  public async populateCache(catalogName: CatalogName, culture: ApiCulture, id?: number): Promise&lt;void | CatalogEntryName | null&gt; {&#10;    const catalog = await this.fetchCatalog(&#10;      catalogName,&#10;      { culture },&#10;    )&#10;    await this.cache.setEntries(&#10;      catalogName,&#10;      culture,&#10;      catalog,&#10;    )&#10;&#10;    if (id !== undefined) {&#10;      const queriedKey = catalog.find(({ id: entryId }) =&gt; entryId === id)&#10;      return queriedKey&#10;        ? {&#10;            name: queriedKey.name,&#10;            namePlural: queriedKey.name_plurial,&#10;          }&#10;        : null&#10;    }&#10;  }&#10;&#10;  public async getCatalogEntries(catalogName: CatalogName, options?: Pick&lt;ApiSearchParams, 'culture'&gt;): Promise&lt;CatalogEntry[]&gt; {&#10;    try {&#10;      return await this.cache.getEntries(catalogName, options?.culture ?? this.config.culture)&#10;    }&#10;    catch (e) {&#10;      if (e instanceof CacheExpiredError) {&#10;        await this.populateCache(catalogName, options?.culture ?? this.config.culture)&#10;        return this.cache.getEntries(catalogName, options?.culture ?? this.config.culture)&#10;      }&#10;      else {&#10;        throw e&#10;      }&#10;    }&#10;  }&#10;&#10;  public async fetchCatalog(catalogName: CatalogName, options?: Pick&lt;ApiSearchParams, 'culture'&gt;): Promise&lt;CatalogEntry[]&gt; {&#10;    return this.get(&#10;      ['catalogs', catalogName],&#10;      z.array(CatalogEntrySchema),&#10;      options,&#10;    )&#10;  }&#10;&#10;  public async fetchAgencies(options?: Pick&lt;ApiSearchParams, 'culture' | 'limit' | 'offset'&gt;) {&#10;    return this.get(&#10;      ['agencies'],&#10;      z.object({&#10;        total_items: z.number(),&#10;        agencies: getAgencySchema(this.getLocalizedCatalogTransformer(&#10;          options?.culture ?? this.config.culture,&#10;        ), this.config).array(),&#10;        timestamp: z.number(),&#10;      },&#10;      ),&#10;    )&#10;  }&#10;&#10;  public async fetchProperties(agencyId: number, options?: Pick&lt;ApiSearchParams, 'culture' | 'limit' | 'offset' | 'timestamp' | 'step' | 'status' | 'group'&gt;) {&#10;    return this.get(&#10;      ['agencies', agencyId.toString(), 'properties'],&#10;      z.object({&#10;        total_items: z.number(),&#10;        timestamp: z.number(),&#10;        properties: getPropertySchema(this.getLocalizedCatalogTransformer(&#10;          options?.culture ?? this.config.culture,&#10;        )).array(),&#10;      }),&#10;      options,&#10;    )&#10;  }&#10;&#10;  private getLocalizedCatalogTransformer(culture: ApiCulture): LocalizedCatalogTransformer {&#10;    return async (catalogName, id) =&gt; {&#10;      if (!this.config.catalogs.transform.active) {&#10;        return `${catalogName}.${id}`&#10;      }&#10;      if (this.config.catalogs.transform.transformFn) {&#10;        return this.config.catalogs.transform.transformFn(&#10;          catalogName,&#10;          culture,&#10;          id,&#10;        )&#10;      }&#10;&#10;      return this.catalogTransformer(catalogName, culture, id)&#10;    }&#10;  }&#10;&#10;  private async catalogTransformer(catalogName: CatalogName, culture: ApiCulture, id: number): Promise&lt;CatalogEntryName | null&gt; {&#10;    try {&#10;      return await this.cache.getEntry(catalogName, culture, id)&#10;    }&#10;    catch (e) {&#10;      if (e instanceof CacheExpiredError) {&#10;        return await this.populateCache(catalogName, culture, id)&#10;      }&#10;      else {&#10;        throw e&#10;      }&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="updatedContent" value="// Main exports&#10;export { Apimo, type AdditionalConfig, DEFAULT_ADDITIONAL_CONFIG, DEFAULT_BASE_URL } from './core/api'&#10;&#10;// Cache adapters&#10;export { MemoryCache } from './services/storage/memory.cache'&#10;export { FilesystemCache } from './services/storage/filesystem.cache'&#10;export { DummyCache } from './services/storage/dummy.cache'&#10;&#10;// Cache types and errors&#10;export { CacheExpiredError, type ApiCacheAdapter, type CatalogEntryName } from './services/storage/types'&#10;&#10;// Schema types&#10;export type { CatalogDefinition, CatalogEntry, CatalogTransformer, LocalizedCatalogTransformer } from './schemas/common'&#10;&#10;// Constants&#10;export type { CatalogName } from './consts/catalogs'&#10;export type { ApiCulture } from './consts/languages'&#10;&#10;// Utility types&#10;export type { DeepPartial } from './types'&#10;export type { ApiSearchParams } from './utils/url'&#10;&#10;// Backward compatibility - keep Api as alias&#10;export { Apimo as Api } from './core/api'" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts" />
              <option name="originalContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})&#10;" />
              <option name="updatedContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;&#10;  describe('behavior consistency', () =&gt; {&#10;    it('should behave consistently across multiple calls', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      // Multiple setEntries calls should not throw&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;&#10;      // Multiple getEntry calls should always throw&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should maintain dummy behavior regardless of cache state', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;&#10;      // Should throw before any operations&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after setting entries&#10;      await cache.setEntries(catalogName, culture, [{ id: 1, name: 'Test', name_plurial: 'Tests' }])&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after multiple operations&#10;      await cache.setEntries(catalogName, culture, [])&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>