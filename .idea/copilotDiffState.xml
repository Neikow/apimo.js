<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts" />
              <option name="originalContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})&#10;" />
              <option name="updatedContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;&#10;  describe('behavior consistency', () =&gt; {&#10;    it('should behave consistently across multiple calls', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      // Multiple setEntries calls should not throw&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;&#10;      // Multiple getEntry calls should always throw&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should maintain dummy behavior regardless of cache state', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;&#10;      // Should throw before any operations&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after setting entries&#10;      await cache.setEntries(catalogName, culture, [{ id: 1, name: 'Test', name_plurial: 'Tests' }])&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after multiple operations&#10;      await cache.setEntries(catalogName, culture, [])&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>