<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/ci.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/ci.yml" />
              <option name="updatedContent" value="name: Continuous Integration&#10;&#10;on:&#10;  push:&#10;    branches: [ main, develop ]&#10;  pull_request:&#10;    branches: [ main, develop ]&#10;&#10;jobs:&#10;  test-and-lint:&#10;    runs-on: ubuntu-latest&#10;&#10;    strategy:&#10;      matrix:&#10;        node-version: [18, 20, 22]&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup Node.js ${{ matrix.node-version }}&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: ${{ matrix.node-version }}&#10;          cache: 'yarn'&#10;&#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;&#10;      - name: Run linting&#10;        run: yarn lint&#10;&#10;      - name: Run tests&#10;        run: yarn test&#10;&#10;      - name: Run test coverage&#10;        run: yarn test-coverage&#10;&#10;      - name: Upload coverage reports to Codecov&#10;        uses: codecov/codecov-action@v4&#10;        if: matrix.node-version == 20&#10;        with:&#10;          file: ./coverage/lcov.info&#10;          fail_ci_if_error: false&#10;        env:&#10;          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.github/workflows/publish.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/publish.yml" />
              <option name="updatedContent" value="name: Build, Test &amp; Publish to NPM&#10;&#10;on:&#10;  push:&#10;    tags:&#10;      - 'v*'  # Triggers on version tags like v1.0.0, v1.2.3, etc.&#10;  workflow_dispatch:  # Allows manual triggering&#10;&#10;jobs:&#10;  test:&#10;    runs-on: ubuntu-latest&#10;    &#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;        &#10;      - name: Setup Node.js&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: '18'&#10;          cache: 'yarn'&#10;          &#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;        &#10;      - name: Run linting&#10;        run: yarn lint&#10;        &#10;      - name: Run tests&#10;        run: yarn test&#10;        &#10;      - name: Run test coverage&#10;        run: yarn test-coverage&#10;&#10;  build-and-publish:&#10;    needs: test&#10;    runs-on: ubuntu-latest&#10;    &#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;        &#10;      - name: Setup Node.js&#10;        uses: actions/setup-node@v4&#10;        with:&#10;          node-version: '18'&#10;          cache: 'yarn'&#10;          registry-url: 'https://registry.npmjs.org'&#10;          &#10;      - name: Install dependencies&#10;        run: yarn install --frozen-lockfile&#10;        &#10;      - name: Build package&#10;        run: yarn build&#10;        &#10;      - name: Check if dist directory exists&#10;        run: |&#10;          if [ ! -d &quot;dist&quot; ]; then&#10;            echo &quot;Build failed: dist directory not found&quot;&#10;            exit 1&#10;          fi&#10;          echo &quot;Build successful: dist directory created&quot;&#10;          &#10;      - name: Publish to NPM&#10;        run: npm publish&#10;        env:&#10;          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;apimo.js&quot;,&#10;  &quot;version&quot;: &quot;1.0.1&quot;,&#10;  &quot;description&quot;: &quot;A wrapper for the Apimo API with catalog caching for building custom Real Estate website using their technologies.&quot;,&#10;  &quot;main&quot;: &quot;/dist/index.js&quot;,&#10;  &quot;repository&quot;: {&#10;    &quot;type&quot;: &quot;git&quot;,&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js.git&quot;&#10;  },&#10;  &quot;homepage&quot;: &quot;https://github.com/Neikow/apimo.js&quot;,&#10;  &quot;bugs&quot;: {&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js/issues&quot;&#10;  },&#10;  &quot;keywords&quot;: [&#10;    &quot;api&quot;,&#10;    &quot;apimo&quot;,&#10;    &quot;real-estate&quot;&#10;  ],&#10;  &quot;scripts&quot;: {&#10;    &quot;dev&quot;: &quot;&quot;,&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;run&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;test&quot;: &quot;vitest run&quot;,&#10;    &quot;test-coverage&quot;: &quot;vitest run --coverage&quot;&#10;  },&#10;  &quot;author&quot;: &quot;Vitaly Lysen &lt;vitaly@lysen.dev&gt; (https://lysen.dev)&quot;,&#10;  &quot;license&quot;: &quot;MIT&quot;,&#10;  &quot;dependencies&quot;: {&#10;    &quot;bottleneck&quot;: &quot;^2.19.5&quot;,&#10;    &quot;merge-anything&quot;: &quot;^6.0.6&quot;,&#10;    &quot;zod&quot;: &quot;^3.21.4&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@antfu/eslint-config&quot;: &quot;^5.0.0&quot;,&#10;    &quot;@types/node&quot;: &quot;^24.1.0&quot;,&#10;    &quot;@anatine/zod-mock&quot;: &quot;^3.14.0&quot;,&#10;    &quot;@faker-js/faker&quot;: &quot;^9.9.0&quot;,&#10;    &quot;@vitest/coverage-v8&quot;: &quot;^3.2.4&quot;,&#10;    &quot;dotenv&quot;: &quot;^17.2.1&quot;,&#10;    &quot;eslint&quot;: &quot;^9.32.0&quot;,&#10;    &quot;typescript&quot;: &quot;^5.9.2&quot;,&#10;    &quot;vitest&quot;: &quot;^3.2.4&quot;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;apimo.js&quot;,&#10;  &quot;version&quot;: &quot;1.0.1&quot;,&#10;  &quot;description&quot;: &quot;A wrapper for the Apimo API with catalog caching for building custom Real Estate website using their technologies.&quot;,&#10;  &quot;main&quot;: &quot;/dist/index.js&quot;,&#10;  &quot;repository&quot;: {&#10;    &quot;type&quot;: &quot;git&quot;,&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js.git&quot;&#10;  },&#10;  &quot;homepage&quot;: &quot;https://github.com/Neikow/apimo.js&quot;,&#10;  &quot;bugs&quot;: {&#10;    &quot;url&quot;: &quot;https://github.com/Neikow/apimo.js/issues&quot;&#10;  },&#10;  &quot;keywords&quot;: [&#10;    &quot;api&quot;,&#10;    &quot;apimo&quot;,&#10;    &quot;real-estate&quot;&#10;  ],&#10;  &quot;scripts&quot;: {&#10;    &quot;dev&quot;: &quot;&quot;,&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;run&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;test&quot;: &quot;vitest run&quot;,&#10;    &quot;test-coverage&quot;: &quot;vitest run --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint .&quot;&#10;  },&#10;  &quot;author&quot;: &quot;Vitaly Lysen &lt;vitaly@lysen.dev&gt; (https://lysen.dev)&quot;,&#10;  &quot;license&quot;: &quot;MIT&quot;,&#10;  &quot;dependencies&quot;: {&#10;    &quot;bottleneck&quot;: &quot;^2.19.5&quot;,&#10;    &quot;merge-anything&quot;: &quot;^6.0.6&quot;,&#10;    &quot;zod&quot;: &quot;^3.21.4&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@antfu/eslint-config&quot;: &quot;^5.0.0&quot;,&#10;    &quot;@types/node&quot;: &quot;^24.1.0&quot;,&#10;    &quot;@anatine/zod-mock&quot;: &quot;^3.14.0&quot;,&#10;    &quot;@faker-js/faker&quot;: &quot;^9.9.0&quot;,&#10;    &quot;@vitest/coverage-v8&quot;: &quot;^3.2.4&quot;,&#10;    &quot;dotenv&quot;: &quot;^17.2.1&quot;,&#10;    &quot;eslint&quot;: &quot;^9.32.0&quot;,&#10;    &quot;typescript&quot;: &quot;^5.9.2&quot;,&#10;    &quot;vitest&quot;: &quot;^3.2.4&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts" />
              <option name="originalContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})&#10;" />
              <option name="updatedContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;&#10;  describe('behavior consistency', () =&gt; {&#10;    it('should behave consistently across multiple calls', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      // Multiple setEntries calls should not throw&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;&#10;      // Multiple getEntry calls should always throw&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should maintain dummy behavior regardless of cache state', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;&#10;      // Should throw before any operations&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after setting entries&#10;      await cache.setEntries(catalogName, culture, [{ id: 1, name: 'Test', name_plurial: 'Tests' }])&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after multiple operations&#10;      await cache.setEntries(catalogName, culture, [])&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>