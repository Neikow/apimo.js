<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/storage/dummy.cache.test.ts" />
              <option name="originalContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})&#10;" />
              <option name="updatedContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { afterEach, beforeEach, describe, expect, it } from 'vitest'&#10;import { DummyCache } from './dummy.cache'&#10;import { CacheExpiredError } from './types'&#10;&#10;describe('cache - Dummy', () =&gt; {&#10;  let cache: DummyCache&#10;&#10;  beforeEach(() =&gt; {&#10;    cache = new DummyCache()&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // No cleanup needed for dummy cache&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should create an instance without any configuration', () =&gt; {&#10;      const dummyCache = new DummyCache()&#10;      expect(dummyCache).toBeInstanceOf(DummyCache)&#10;    })&#10;  })&#10;&#10;  describe('setEntries', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    it('should not throw when setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle empty entries array', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.setEntries(catalogName, culture, [])).resolves.toBeUndefined()&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await expect(cache.setEntries('book_step', 'en', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_land', 'fr', entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries('property_type', 'de', entries)).resolves.toBeUndefined()&#10;    })&#10;  })&#10;&#10;  describe('getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;&#10;    it('should always throw CacheExpiredError regardless of parameters', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for any ID', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 0)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, -1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError for different catalogs and cultures', async () =&gt; {&#10;      await expect(cache.getEntry('book_step', 'en', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_land', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry('property_type', 'de', 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError even after setting entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;&#10;  describe('behavior consistency', () =&gt; {&#10;    it('should behave consistently across multiple calls', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const entries = [{ id: 1, name: 'Item 1', name_plurial: 'Items 1' }]&#10;&#10;      // Multiple setEntries calls should not throw&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;      await expect(cache.setEntries(catalogName, culture, entries)).resolves.toBeUndefined()&#10;&#10;      // Multiple getEntry calls should always throw&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should maintain dummy behavior regardless of cache state', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;&#10;      // Should throw before any operations&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after setting entries&#10;      await cache.setEntries(catalogName, culture, [{ id: 1, name: 'Test', name_plurial: 'Tests' }])&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Should still throw after multiple operations&#10;      await cache.setEntries(catalogName, culture, [])&#10;      await expect(cache.getEntry(catalogName, culture, 999)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;  })&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/storage/dummy.cache.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/storage/dummy.cache.ts" />
              <option name="originalContent" value="import type { ApiCacheAdapter, CatalogEntryName } from './types'&#10;import { CacheExpiredError } from './types'&#10;&#10;export class DummyCache implements ApiCacheAdapter {&#10;  constructor() {&#10;  }&#10;&#10;  async setEntries(): Promise&lt;void&gt; {&#10;  }&#10;&#10;  async getEntry(): Promise&lt;CatalogEntryName&gt; {&#10;    throw new CacheExpiredError()&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import type { CatalogEntry } from '../../schemas/common'&#10;import type { ApiCacheAdapter, CatalogEntryName } from './types'&#10;import { CacheExpiredError } from './types'&#10;&#10;export class DummyCache implements ApiCacheAdapter {&#10;  constructor() {&#10;  }&#10;&#10;  async setEntries(_catalogName: CatalogName, _culture: ApiCulture, _entries: CatalogEntry[]): Promise&lt;void&gt; {&#10;  }&#10;&#10;  async getEntry(_catalogName: CatalogName, _culture: ApiCulture, _id: number): Promise&lt;CatalogEntryName | null&gt; {&#10;    throw new CacheExpiredError()&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/storage/filesystem.cache.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/storage/filesystem.cache.test.ts" />
              <option name="originalContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { describe, expect, it, beforeEach, afterEach } from 'vitest'&#10;import { FilesystemCache } from './filesystem.cache'&#10;import { CacheExpiredError } from './types'&#10;import { rmSync, existsSync, mkdirSync } from 'node:fs'&#10;import { readFile, writeFile } from 'node:fs/promises'&#10;import * as path from 'node:path'&#10;import * as os from 'node:os'&#10;&#10;describe('cache - Filesystem', () =&gt; {&#10;  let tempDir: string&#10;  let cache: FilesystemCache&#10;&#10;  beforeEach(() =&gt; {&#10;    // Create a unique temporary directory for each test&#10;    tempDir = path.join(os.tmpdir(), `filesystem-cache-test-${Date.now()}-${Math.random().toString(36).slice(2)}`)&#10;    mkdirSync(tempDir, { recursive: true })&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // Clean up the temporary directory after each test&#10;    if (existsSync(tempDir)) {&#10;      rmSync(tempDir, { recursive: true, force: true })&#10;    }&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should use default cache location and expiration when no settings provided', () =&gt; {&#10;      new FilesystemCache()&#10;      expect(existsSync('./cache/catalogs')).toBe(true)&#10;    })&#10;&#10;    it('should create custom cache directory when provided', () =&gt; {&#10;      const customPath = path.join(tempDir, 'custom-cache')&#10;      cache = new FilesystemCache({ path: customPath })&#10;      expect(existsSync(customPath)).toBe(true)&#10;    })&#10;&#10;    it('should use custom expiration time when provided', () =&gt; {&#10;      const customExpiration = 60000&#10;      cache = new FilesystemCache({&#10;        path: tempDir,&#10;        cacheExpirationMs: customExpiration,&#10;      })&#10;      // The expiration time is private, but we can test its effect&#10;      expect(cache).toBeInstanceOf(FilesystemCache)&#10;    })&#10;&#10;    it('should create nested directories recursively', () =&gt; {&#10;      const nestedPath = path.join(tempDir, 'level1', 'level2', 'cache')&#10;      cache = new FilesystemCache({ path: nestedPath })&#10;      expect(existsSync(nestedPath)).toBe(true)&#10;    })&#10;  })&#10;&#10;  describe('setEntries and getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    beforeEach(() =&gt; {&#10;      cache = new FilesystemCache({ path: tempDir })&#10;    })&#10;&#10;    it('should store and retrieve entries correctly', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await cache.setEntries(catalogName, culture, entries)&#10;&#10;      const entry1 = await cache.getEntry(catalogName, culture, 1)&#10;      const entry2 = await cache.getEntry(catalogName, culture, 2)&#10;&#10;      expect(entry1).toEqual({ name: 'Item 1', namePlural: 'Items 1' })&#10;      expect(entry2).toEqual({ name: 'Item 2', namePlural: 'Items 2' })&#10;    })&#10;&#10;    it('should create cache file with correct format', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await cache.setEntries(catalogName, culture, entries)&#10;&#10;      const filePath = path.join(tempDir, `${catalogName}-${culture}.json`)&#10;      expect(existsSync(filePath)).toBe(true)&#10;&#10;      const fileContent = await readFile(filePath, 'utf-8')&#10;      const parsed = JSON.parse(fileContent)&#10;&#10;      expect(parsed).toHaveProperty('timestamp')&#10;      expect(parsed).toHaveProperty('cache')&#10;      expect(parsed.cache).toEqual({&#10;        '1': { name: 'Item 1', namePlural: 'Items 1' },&#10;        '2': { name: 'Item 2', namePlural: 'Items 2' },&#10;      })&#10;      expect(typeof parsed.timestamp).toBe('number')&#10;    })&#10;&#10;    it('should return null for non-existent entry', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await cache.setEntries(catalogName, culture, entries)&#10;&#10;      const entry = await cache.getEntry(catalogName, culture, 999)&#10;      expect(entry).toBeNull()&#10;    })&#10;&#10;    it('should throw CacheExpiredError when cache file does not exist', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError when cache has expired', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const expiredCache = new FilesystemCache({&#10;        path: tempDir,&#10;        cacheExpirationMs: 1,&#10;      })&#10;      await expiredCache.setEntries(catalogName, culture, entries)&#10;&#10;      await new Promise(resolve =&gt; setTimeout(resolve, 10))&#10;&#10;      await expect(expiredCache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await cache.setEntries('book_step', 'en', entries)&#10;      await cache.setEntries('property_land', 'fr', entries)&#10;&#10;      const entry1 = await cache.getEntry('book_step', 'en', 1)&#10;      const entry2 = await cache.getEntry('property_land', 'fr', 1)&#10;&#10;      expect(entry1).toEqual({ name: 'Item 1', namePlural: 'Items 1' })&#10;      expect(entry2).toEqual({ name: 'Item 1', namePlural: 'Items 1' })&#10;&#10;      await expect(cache.getEntry('book_step', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Verify separate files were created&#10;      expect(existsSync(path.join(tempDir, 'book_step-en.json'))).toBe(true)&#10;      expect(existsSync(path.join(tempDir, 'property_land-fr.json'))).toBe(true)&#10;      expect(existsSync(path.join(tempDir, 'book_step-fr.json'))).toBe(false)&#10;    })&#10;&#10;    it('should overwrite existing cache when setting new entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'property_land'&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;&#10;      const newEntries = [{ id: 3, name: 'New Item', name_plurial: 'New Items' }]&#10;      await cache.setEntries(catalogName, culture, newEntries)&#10;&#10;      const newEntry = await cache.getEntry(catalogName, culture, 3)&#10;      expect(newEntry).toEqual({ name: 'New Item', namePlural: 'New Items' })&#10;&#10;      const oldEntry = await cache.getEntry(catalogName, culture, 1)&#10;      expect(oldEntry).toBeNull()&#10;    })&#10;&#10;    it('should handle entries with undefined name_plurial', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entriesWithUndefined = [&#10;        { id: 1, name: 'Item 1', name_plurial: undefined },&#10;        { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;      ]&#10;&#10;      await cache.setEntries(catalogName, culture, entriesWithUndefined)&#10;&#10;      const entry1 = await cache.getEntry(catalogName, culture, 1)&#10;      const entry2 = await cache.getEntry(catalogName, culture, 2)&#10;&#10;      expect(entry1).toEqual({ name: 'Item 1', namePlural: undefined })&#10;      expect(entry2).toEqual({ name: 'Item 2', namePlural: 'Items 2' })&#10;    })&#10;&#10;    it('should handle large entry IDs correctly', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const largeIdEntries = [&#10;        { id: 999999999, name: 'Large ID Item', name_plurial: 'Large ID Items' },&#10;      ]&#10;&#10;      await cache.setEntries(catalogName, culture, largeIdEntries)&#10;&#10;      const entry = await cache.getEntry(catalogName, culture, 999999999)&#10;      expect(entry).toEqual({ name: 'Large ID Item', namePlural: 'Large ID Items' })&#10;    })&#10;&#10;    it('should persist cache across multiple FilesystemCache instances', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;&#10;      // Create cache with first instance&#10;      const cache1 = new FilesystemCache({ path: tempDir })&#10;      await cache1.setEntries(catalogName, culture, entries)&#10;&#10;      // Access cache with second instance&#10;      const cache2 = new FilesystemCache({ path: tempDir })&#10;      const entry = await cache2.getEntry(catalogName, culture, 1)&#10;&#10;      expect(entry).toEqual({ name: 'Item 1', namePlural: 'Items 1' })&#10;    })&#10;  })&#10;&#10;  describe('error handling', () =&gt; {&#10;    beforeEach(() =&gt; {&#10;      cache = new FilesystemCache({ path: tempDir })&#10;    })&#10;&#10;    it('should handle malformed JSON files gracefully', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const filePath = path.join(tempDir, `${catalogName}-${culture}.json`)&#10;&#10;      // Write malformed JSON&#10;      await writeFile(filePath, 'invalid json content')&#10;&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow()&#10;    })&#10;&#10;    it('should handle files with missing timestamp', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const filePath = path.join(tempDir, `${catalogName}-${culture}.json`)&#10;&#10;      // Write JSON without timestamp&#10;      await writeFile(filePath, JSON.stringify({&#10;        cache: { '1': { name: 'Test', namePlural: 'Tests' } }&#10;      }))&#10;&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow()&#10;    })&#10;&#10;    it('should handle files with missing cache property', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const filePath = path.join(tempDir, `${catalogName}-${culture}.json`)&#10;&#10;      // Write JSON without cache property&#10;      await writeFile(filePath, JSON.stringify({&#10;        timestamp: Date.now()&#10;      }))&#10;&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow()&#10;    })&#10;  }&#10;})&#10;" />
              <option name="updatedContent" value="import type { CatalogName } from '../../consts/catalogs'&#10;import type { ApiCulture } from '../../consts/languages'&#10;import { describe, expect, it, beforeEach, afterEach } from 'vitest'&#10;import { FilesystemCache } from './filesystem.cache'&#10;import { CacheExpiredError } from './types'&#10;import { rmSync, existsSync, mkdirSync } from 'node:fs'&#10;import { readFile, writeFile } from 'node:fs/promises'&#10;import * as path from 'node:path'&#10;import * as os from 'node:os'&#10;&#10;describe('cache - Filesystem', () =&gt; {&#10;  let tempDir: string&#10;  let cache: FilesystemCache&#10;&#10;  beforeEach(() =&gt; {&#10;    // Create a unique temporary directory for each test&#10;    tempDir = path.join(os.tmpdir(), `filesystem-cache-test-${Date.now()}-${Math.random().toString(36).slice(2)}`)&#10;    mkdirSync(tempDir, { recursive: true })&#10;  })&#10;&#10;  afterEach(() =&gt; {&#10;    // Clean up the temporary directory after each test&#10;    if (existsSync(tempDir)) {&#10;      rmSync(tempDir, { recursive: true, force: true })&#10;    }&#10;  })&#10;&#10;  describe('constructor', () =&gt; {&#10;    it('should use default cache location and expiration when no settings provided', () =&gt; {&#10;      new FilesystemCache()&#10;      expect(existsSync('./cache/catalogs')).toBe(true)&#10;    })&#10;&#10;    it('should create custom cache directory when provided', () =&gt; {&#10;      const customPath = path.join(tempDir, 'custom-cache')&#10;      cache = new FilesystemCache({ path: customPath })&#10;      expect(existsSync(customPath)).toBe(true)&#10;    })&#10;&#10;    it('should use custom expiration time when provided', () =&gt; {&#10;      const customExpiration = 60000&#10;      cache = new FilesystemCache({&#10;        path: tempDir,&#10;        cacheExpirationMs: customExpiration,&#10;      })&#10;      // The expiration time is private, but we can test its effect&#10;      expect(cache).toBeInstanceOf(FilesystemCache)&#10;    })&#10;&#10;    it('should create nested directories recursively', () =&gt; {&#10;      const nestedPath = path.join(tempDir, 'level1', 'level2', 'cache')&#10;      cache = new FilesystemCache({ path: nestedPath })&#10;      expect(existsSync(nestedPath)).toBe(true)&#10;    })&#10;  })&#10;&#10;  describe('setEntries and getEntry', () =&gt; {&#10;    const culture: ApiCulture = 'en'&#10;    const entries = [&#10;      { id: 1, name: 'Item 1', name_plurial: 'Items 1' },&#10;      { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;    ]&#10;&#10;    beforeEach(() =&gt; {&#10;      cache = new FilesystemCache({ path: tempDir })&#10;    })&#10;&#10;    it('should store and retrieve entries correctly', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await cache.setEntries(catalogName, culture, entries)&#10;&#10;      const entry1 = await cache.getEntry(catalogName, culture, 1)&#10;      const entry2 = await cache.getEntry(catalogName, culture, 2)&#10;&#10;      expect(entry1).toEqual({ name: 'Item 1', namePlural: 'Items 1' })&#10;      expect(entry2).toEqual({ name: 'Item 2', namePlural: 'Items 2' })&#10;    })&#10;&#10;    it('should create cache file with correct format', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await cache.setEntries(catalogName, culture, entries)&#10;&#10;      const filePath = path.join(tempDir, `${catalogName}-${culture}.json`)&#10;      expect(existsSync(filePath)).toBe(true)&#10;&#10;      const fileContent = await readFile(filePath, 'utf-8')&#10;      const parsed = JSON.parse(fileContent)&#10;&#10;      expect(parsed).toHaveProperty('timestamp')&#10;      expect(parsed).toHaveProperty('cache')&#10;      expect(parsed.cache).toEqual({&#10;        '1': { name: 'Item 1', namePlural: 'Items 1' },&#10;        '2': { name: 'Item 2', namePlural: 'Items 2' },&#10;      })&#10;      expect(typeof parsed.timestamp).toBe('number')&#10;    })&#10;&#10;    it('should return null for non-existent entry', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await cache.setEntries(catalogName, culture, entries)&#10;&#10;      const entry = await cache.getEntry(catalogName, culture, 999)&#10;      expect(entry).toBeNull()&#10;    })&#10;&#10;    it('should throw CacheExpiredError when cache file does not exist', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should throw CacheExpiredError when cache has expired', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const expiredCache = new FilesystemCache({&#10;        path: tempDir,&#10;        cacheExpirationMs: 1,&#10;      })&#10;      await expiredCache.setEntries(catalogName, culture, entries)&#10;&#10;      await new Promise(resolve =&gt; setTimeout(resolve, 10))&#10;&#10;      await expect(expiredCache.getEntry(catalogName, culture, 1)).rejects.toThrow(CacheExpiredError)&#10;    })&#10;&#10;    it('should handle different catalog and culture combinations', async () =&gt; {&#10;      await cache.setEntries('book_step', 'en', entries)&#10;      await cache.setEntries('property_land', 'fr', entries)&#10;&#10;      const entry1 = await cache.getEntry('book_step', 'en', 1)&#10;      const entry2 = await cache.getEntry('property_land', 'fr', 1)&#10;&#10;      expect(entry1).toEqual({ name: 'Item 1', namePlural: 'Items 1' })&#10;      expect(entry2).toEqual({ name: 'Item 1', namePlural: 'Items 1' })&#10;&#10;      await expect(cache.getEntry('book_step', 'fr', 1)).rejects.toThrow(CacheExpiredError)&#10;&#10;      // Verify separate files were created&#10;      expect(existsSync(path.join(tempDir, 'book_step-en.json'))).toBe(true)&#10;      expect(existsSync(path.join(tempDir, 'property_land-fr.json'))).toBe(true)&#10;      expect(existsSync(path.join(tempDir, 'book_step-fr.json'))).toBe(false)&#10;    })&#10;&#10;    it('should overwrite existing cache when setting new entries', async () =&gt; {&#10;      const catalogName: CatalogName = 'property_land'&#10;&#10;      await cache.setEntries(catalogName, culture, entries)&#10;&#10;      const newEntries = [{ id: 3, name: 'New Item', name_plurial: 'New Items' }]&#10;      await cache.setEntries(catalogName, culture, newEntries)&#10;&#10;      const newEntry = await cache.getEntry(catalogName, culture, 3)&#10;      expect(newEntry).toEqual({ name: 'New Item', namePlural: 'New Items' })&#10;&#10;      const oldEntry = await cache.getEntry(catalogName, culture, 1)&#10;      expect(oldEntry).toBeNull()&#10;    })&#10;&#10;    it('should handle entries with undefined name_plurial', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const entriesWithUndefined = [&#10;        { id: 1, name: 'Item 1', name_plurial: undefined },&#10;        { id: 2, name: 'Item 2', name_plurial: 'Items 2' },&#10;      ]&#10;&#10;      await cache.setEntries(catalogName, culture, entriesWithUndefined)&#10;&#10;      const entry1 = await cache.getEntry(catalogName, culture, 1)&#10;      const entry2 = await cache.getEntry(catalogName, culture, 2)&#10;&#10;      expect(entry1).toEqual({ name: 'Item 1', namePlural: undefined })&#10;      expect(entry2).toEqual({ name: 'Item 2', namePlural: 'Items 2' })&#10;    })&#10;&#10;    it('should handle large entry IDs correctly', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const largeIdEntries = [&#10;        { id: 999999999, name: 'Large ID Item', name_plurial: 'Large ID Items' },&#10;      ]&#10;&#10;      await cache.setEntries(catalogName, culture, largeIdEntries)&#10;&#10;      const entry = await cache.getEntry(catalogName, culture, 999999999)&#10;      expect(entry).toEqual({ name: 'Large ID Item', namePlural: 'Large ID Items' })&#10;    })&#10;&#10;    it('should persist cache across multiple FilesystemCache instances', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;&#10;      // Create cache with first instance&#10;      const cache1 = new FilesystemCache({ path: tempDir })&#10;      await cache1.setEntries(catalogName, culture, entries)&#10;&#10;      // Access cache with second instance&#10;      const cache2 = new FilesystemCache({ path: tempDir })&#10;      const entry = await cache2.getEntry(catalogName, culture, 1)&#10;&#10;      expect(entry).toEqual({ name: 'Item 1', namePlural: 'Items 1' })&#10;    })&#10;  })&#10;&#10;  describe('error handling', () =&gt; {&#10;    beforeEach(() =&gt; {&#10;      cache = new FilesystemCache({ path: tempDir })&#10;    })&#10;&#10;    it('should handle malformed JSON files gracefully', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const filePath = path.join(tempDir, `${catalogName}-${culture}.json`)&#10;      &#10;      // Write malformed JSON&#10;      await writeFile(filePath, 'invalid json content')&#10;&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow()&#10;    })&#10;&#10;    it('should handle files with missing timestamp', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const filePath = path.join(tempDir, `${catalogName}-${culture}.json`)&#10;      &#10;      // Write JSON without timestamp&#10;      await writeFile(filePath, JSON.stringify({&#10;        cache: { '1': { name: 'Test', namePlural: 'Tests' } }&#10;      }))&#10;&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow()&#10;    })&#10;&#10;    it('should handle files with missing cache property', async () =&gt; {&#10;      const catalogName: CatalogName = 'book_step'&#10;      const culture: ApiCulture = 'en'&#10;      const filePath = path.join(tempDir, `${catalogName}-${culture}.json`)&#10;      &#10;      // Write JSON without cache property&#10;      await writeFile(filePath, JSON.stringify({&#10;        timestamp: Date.now()&#10;      }))&#10;&#10;      await expect(cache.getEntry(catalogName, culture, 1)).rejects.toThrow()&#10;    })&#10;  })&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>